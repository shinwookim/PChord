
@article{stoica_chord_2003,
	title = {Chord: a scalable peer-to-peer lookup protocol for {Internet} applications},
	volume = {11},
	issn = {1558-2566},
	shorttitle = {Chord},
	url = {https://ieeexplore.ieee.org/document/1180543},
	doi = {10.1109/TNET.2002.808407},
	abstract = {A fundamental problem that confronts peer-to-peer applications is the efficient location of the node that stores a desired data item. This paper presents Chord, a distributed lookup protocol that addresses this problem. Chord provides support for just one operation: given a key, it maps the key onto a node. Data location can be easily implemented on top of Chord by associating a key with each data item, and storing the key/data pair at the node to which the key maps. Chord adapts efficiently as nodes join and leave the system, and can answer queries even if the system is continuously changing. Results from theoretical analysis and simulations show that Chord is scalable: Communication cost and the state maintained by each node scale logarithmically with the number of Chord nodes.},
	number = {1},
	urldate = {2024-12-16},
	journal = {IEEE/ACM Transactions on Networking},
	author = {Stoica, I. and Morris, R. and Liben-Nowell, D. and Karger, D.R. and Kaashoek, M.F. and Dabek, F. and Balakrishnan, H.},
	month = feb,
	year = {2003},
	note = {Conference Name: IEEE/ACM Transactions on Networking},
	keywords = {Analytical models, Application software, Centralized control, Computer science, Costs, Internet, Network servers, Peer to peer computing, Protocols, Routing},
	pages = {17--32},
}

@article{stoica_chord_2001,
	title = {Chord: {A} scalable peer-to-peer lookup service for internet applications},
	volume = {31},
	issn = {0146-4833},
	shorttitle = {Chord},
	url = {https://doi.org/10.1145/964723.383071},
	doi = {10.1145/964723.383071},
	abstract = {A fundamental problem that confronts peer-to-peer applications is to efficiently locate the node that stores a particular data item. This paper presents Chord, a distributed lookup protocol that addresses this problem. Chord provides support for just one operation: given a key, it maps the key onto a node. Data location can be easily implemented on top of Chord by associating a key with each data item, and storing the key/data item pair at the node to which the key maps. Chord adapts efficiently as nodes join and leave the system, and can answer queries even if the system is continuously changing. Results from theoretical analysis, simulations, and experiments show that Chord is scalable, with communication cost and the state maintained by each node scaling logarithmically with the number of Chord nodes.},
	number = {4},
	urldate = {2024-12-16},
	journal = {SIGCOMM Comput. Commun. Rev.},
	author = {Stoica, Ion and Morris, Robert and Karger, David and Kaashoek, M. Frans and Balakrishnan, Hari},
	month = aug,
	year = {2001},
	pages = {149--160},
}

@inproceedings{liben-nowell_analysis_2002,
	address = {New York, NY, USA},
	series = {{PODC} '02},
	title = {Analysis of the evolution of peer-to-peer systems},
	isbn = {978-1-58113-485-8},
	url = {https://doi.org/10.1145/571825.571863},
	doi = {10.1145/571825.571863},
	abstract = {In this paper, we give a theoretical analysis of peer-to-peer (P2P) networks operating in the face of concurrent joins and unexpected departures. We focus on Chord, a recently developed P2P system that implements a distributed hash table abstraction, and study the process by which Chord maintains its distributed state as nodes join and leave the system. We argue that traditional performance measures based on run-time are uninformative for a continually running P2P network, and that the rate at which nodes in the network need to participate to maintain system state is a more useful metric. We give a general lower bound on this rate for a network to remain connected, and prove that an appropriately modified version of Chord's maintenance rate is within a logarithmic factor of the optimum rate.},
	urldate = {2024-12-16},
	booktitle = {Proceedings of the twenty-first annual symposium on {Principles} of distributed computing},
	publisher = {Association for Computing Machinery},
	author = {Liben-Nowell, David and Balakrishnan, Hari and Karger, David},
	month = jul,
	year = {2002},
	pages = {233--242},
}

@article{desai_p_2013,
	title = {P: safe asynchronous event-driven programming},
	volume = {48},
	issn = {0362-1340},
	shorttitle = {P},
	url = {https://doi.org/10.1145/2499370.2462184},
	doi = {10.1145/2499370.2462184},
	abstract = {We describe the design and implementation of P, a domain-specific language to write asynchronous event driven code. P allows the programmer to specify the system as a collection of interacting state machines, which communicate with each other using events. P unifies modeling and programming into one activity for the programmer. Not only can a P program be compiled into executable code, but it can also be tested using model checking techniques. P allows the programmer to specify the environment, used to "close" the system during testing, as nondeterministic ghost machines. Ghost machines are erased during compilation to executable code; a type system ensures that the erasure is semantics preserving.The P language is designed so that a P program can be checked for responsiveness---the ability to handle every event in a timely manner. By default, a machine needs to handle every event that arrives in every state. But handling every event in every state is impractical. The language provides a notion of deferred events where the programmer can annotate when she wants to delay processing an event. The default safety checker looks for presence of unhandled events. The language also provides default liveness checks that an event cannot be potentially deferred forever.P was used to implement and verify the core of the USB device driver stack that ships with Microsoft Windows 8. The resulting driver is more reliable and performs better than its prior incarnation (which did not use P); we have more confidence in the robustness of its design due to the language abstractions and verification provided by P.},
	number = {6},
	urldate = {2024-12-16},
	journal = {SIGPLAN Not.},
	author = {Desai, Ankush and Gupta, Vivek and Jackson, Ethan and Qadeer, Shaz and Rajamani, Sriram and Zufferey, Damien},
	month = jun,
	year = {2013},
	pages = {321--332},
}

@article{zave_using_2012,
	title = {Using lightweight modeling to understand chord},
	volume = {42},
	issn = {0146-4833},
	url = {https://doi.org/10.1145/2185376.2185383},
	doi = {10.1145/2185376.2185383},
	abstract = {Correctness of the Chord ring-maintenance protocol would mean that the protocol can eventually repair all disruptions in the ring structure, given ample time and no further disruptions while it is working. In other words, it is "eventual reachability." Under the same assumptions about failure behavior as made in the Chord papers, no published version of Chord is correct. This result is based on modeling the protocol in Alloy and analyzing it with the Alloy Analyzer. By combining the right selection of pseudocode and textual hints from several papers, and fixing flaws revealed by analysis, it is possible to get a version that may be correct. The paper also discusses the significance of these results, describes briefly how Alloy is used to model and reason about Chord, and compares Alloy analysis to model-checking.},
	number = {2},
	urldate = {2024-12-16},
	journal = {SIGCOMM Comput. Commun. Rev.},
	author = {Zave, Pamela},
	month = mar,
	year = {2012},
	pages = {49--57},
}

@inproceedings{lund_verification_2019,
	title = {Verification of the {Chord} protocol in {TLA}},
	url = {https://www.semanticscholar.org/paper/Verification-of-the-Chord-protocol-in-TLA-Lund/d21038dcf5dc1e37d2a4ed0db693928d8062b629},
	abstract = {In traditional software engineering methodologies, software correctness is established through testing and progressive fault mitigation. Safety properties are established by demonstrating that a sufficiently large number of test cases fail to violate them. In contrast, formal verification methods permit a systems design process where desired safety properties are stated outright in the system specification, and enforced by automated analysis tools. This is of particular interest in designing distributed systems, where safety properties may be easy to formally define and specify, yet hard to implement in practice. Despite this promise, the use of formal methods has largely been confined to academia and certain classes of safety-critical systems. Recently, however, companies like Amazon and Microsoft have adopted formal verification tools to verify distributed system designs. In this thesis, we present a formal specification of the Chord distributed hash table protocol, using the TLA specification language. We specify the protocol at a coarse level with a relaxed failure model, and then increase the granularity and introduce fail-stop failures, yielding a formal specification of Chord with asynchronous messaging and fault-tolerance mechanisms. We first model-check the specification under the constraint that no failures occur, and show that it satisfies critical safety properties. We then show that the introduction of failures leads the specification to admit several behaviors which break the safety properties Chord promises, potentially leading to permanent partitions in the network and performance degradation. As part of this work, we provide an overview of formal verification methods; we discuss certain formalisms and logics involved in modelling and proving algorithms, show potential advantages of applying formal methods to distributed systems design, and identify barriers keeping formal methods from widespread use.},
	urldate = {2024-12-16},
	author = {Lund, Jørgen Aarmo},
	month = may,
	year = {2019},
	file = {Lund - 2019 - Verification of the Chord protocol in TLA:D\:\\zotero\\Coursework\\CS3551\\PChord\\Lund - 2019 - Verification of the Chord protocol in TLA.pdf:application/pdf},
}

@misc{p_developers_formal_2023,
	title = {Formal {Modeling} and {Analysis} of {Distributed} {Systems}},
	shorttitle = {P},
	url = {https://p-org.github.io/P/},
	urldate = {2024-12-16},
	journal = {The P Programming Language},
	author = {P Developers},
	year = {2023},
	file = {P:C\:\\Users\\shinwoo\\Zotero\\storage\\7ALFRCKH\\P.html:text/html},
}

@article{zave_reasoning_2017,
	title = {Reasoning {About} {Identifier} {Spaces}: {How} to {Make} {Chord} {Correct}},
	volume = {43},
	issn = {1939-3520},
	shorttitle = {Reasoning {About} {Identifier} {Spaces}},
	url = {https://ieeexplore.ieee.org/document/7823003},
	doi = {10.1109/TSE.2017.2655056},
	abstract = {The Chord distributed hash table (DHT) is well-known and often used to implement peer-to-peer systems. Chord peers find other peers, and access their data, through a ring-shaped pointer structure in a large identifier space. Despite claims of proven correctness, i.e., eventual reachability, previous work has shown that the Chord ring-maintenance protocol is not correct under its original operating assumptions. Previous work has not, however, discovered whether Chord could be made correct under the same assumptions. The contribution of this paper is to provide the first specification of correct operations and initialization for Chord, an inductive invariant that is necessary and sufficient to support a proof of correctness, and two independent proofs of correctness. One proof is informal and intuitive, and applies to networks of any size. The other proof is based on a formal model in Alloy, and uses fully automated analysis to prove the assertions for networks of bounded size. The two proofs complement each other in several important ways.},
	number = {12},
	urldate = {2024-12-16},
	journal = {IEEE Transactions on Software Engineering},
	author = {Zave, Pamela},
	month = dec,
	year = {2017},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Analytical models, Computers and information processing, distributed computing, Distributed processing, formal verification, Formal verification, Information processing, peer-to-peer computing, Peer-to-peer computing, software engineering, Structural rings},
	pages = {1144--1156},
	file = {Zave - 2017 - Reasoning About Identifier Spaces How to Make Chord Correct:D\:\\zotero\\Coursework\\CS3551\\PChord\\Zave - 2017 - Reasoning About Identifier Spaces How to Make Chord Correct.pdf:application/pdf},
}

@article{jackson_alloy_2002,
	title = {Alloy: a lightweight object modelling notation},
	volume = {11},
	issn = {1049-331X},
	shorttitle = {Alloy},
	url = {https://doi.org/10.1145/505145.505149},
	doi = {10.1145/505145.505149},
	abstract = {Alloy is a little language for describing structural properties. It offers a declaration syntax compatible with graphical object models, and a set-based formula syntax powerful enough to express complex constraints and yet amenable to a fully automatic semantic analysis. Its meaning is given by translation to an even smaller (formally defined) kernel. This paper presents the language in its entirety, and explains its motivation, contributions and deficiencies.},
	number = {2},
	urldate = {2024-12-16},
	journal = {ACM Trans. Softw. Eng. Methodol.},
	author = {Jackson, Daniel},
	month = apr,
	year = {2002},
	pages = {256--290},
}

@article{desai_compositinal_2018,
author = {Desai, Ankush and Phanishayee, Amar and Qadeer, Shaz and Seshia, Sanjit A.},
title = {Compositional programming and testing of dynamic distributed systems},
year = {2018},
issue_date = {November 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {OOPSLA},
url = {https://doi.org/10.1145/3276529},
doi = {10.1145/3276529},
abstract = {A real-world distributed system is rarely implemented as a standalone monolithic system. Instead, it is composed of multiple independent interacting components that together ensure the desired system-level specification. One can scale systematic testing to large, industrial-scale implementations by decomposing the system-level testing problem into a collection of simpler component-level testing problems.  This paper proposes techniques for compositional programming and testing of distributed systems with two central contributions: (1) We propose a module system based on the theory of compositional trace refinement for dynamic systems consisting of asynchronously-communicating state machines, where state machines can be dynamically created, and communication topology of the existing state machines can change at runtime; (2) We present ModP, a programming system that implements our module system to enable compositional reasoning (assume-guarantee) of distributed systems.  We demonstrate the efficacy of our framework by building two practical fault-tolerant distributed systems, a transaction-commit service and a replicated hash-table. ModP helps implement these systems modularly and validate them via compositional testing. We empirically demonstrate that the abstraction-based compositional reasoning approach helps amplify the coverage during testing and scale it to real-world distributed systems. The distributed services built using ModP achieve performance comparable to open-source equivalents.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {159},
numpages = {30},
keywords = {actors, compositional verification, distributed systems, domain-specific language, event-driven programming, module system, systematic testing}
}

@article{deligiannis_programming_2015,
author = {Deligiannis, Pantazis and Donaldson, Alastair F. and Ketema, Jeroen and Lal, Akash and Thomson, Paul},
title = {Asynchronous programming, analysis and testing with state machines},
year = {2015},
issue_date = {June 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2813885.2737996},
doi = {10.1145/2813885.2737996},
abstract = {Programming efficient asynchronous systems is challenging because it can often be hard to express the design declaratively, or to defend against data races and interleaving-dependent assertion violations. Previous work has only addressed these challenges in isolation, by either designing a new declarative language, a new data race detection tool or a new testing technique. We present P#, a language for high-reliability asynchronous programming co-designed with a static data race analysis and systematic concurrency testing infrastructure. We describe our experience using P# to write several distributed protocols and port an industrial-scale system internal to Microsoft, showing that the combined techniques, by leveraging the design of P#, are effective in finding bugs.},
journal = {SIGPLAN Not.},
month = jun,
pages = {154–164},
numpages = {11},
keywords = {systematic concurrency testing, static data race analysis, state machines, concurrency, Asynchronous programming}
}

@article{newcombe_how_2015,
	title = {How {Amazon} web services uses formal methods},
	volume = {58},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/2699417},
	doi = {10.1145/2699417},
	abstract = {Engineers use TLA+ to prevent serious but subtle bugs from reaching production.},
	number = {4},
	urldate = {2024-12-16},
	journal = {Commun. ACM},
	author = {Newcombe, Chris and Rath, Tim and Zhang, Fan and Munteanu, Bogdan and Brooker, Marc and Deardeuff, Michael},
	month = mar,
	year = {2015},
	pages = {66--73},
	file = {Newcombe et al. - 2015 - How Amazon web services uses formal methods:D\:\\zotero\\Coursework\\CS3551\\PChord\\Newcombe et al. - 2015 - How Amazon web services uses formal methods.pdf:application/pdf},
}

@article{lamport_tla_1994,
author = {Lamport, Leslie},
title = {The temporal logic of actions},
year = {1994},
issue_date = {May 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/177492.177726},
doi = {10.1145/177492.177726},
abstract = {The temporal logic of actions (TLA) is a logic for specifying and reasoning about concurrent systems. Systems and their properties are represented in the same logic, so the assertion that a system meets its specification and the assertion that one system implements another are both expressed by logical implication. TLA is very simple; its syntax and complete formal semantics are summarized in about a page. Yet, TLA is not just a logician's toy; it is extremely powerful, both in principle and in practice. This report introduces TLA and describes how it is used to specify and verify concurrent algorithms. The use of TLA to specify and reason about open systems will be described elsewhere.},
journal = {ACM Trans. Program. Lang. Syst.},
month = may,
pages = {872–923},
numpages = {52},
keywords = {concurrent programming, liveness properties, safety properties}
}

@inproceedings{karger_consistent_1997,
author = {Karger, David and Lehman, Eric and Leighton, Tom and Panigrahy, Rina and Levine, Matthew and Lewin, Daniel},
title = {Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web},
year = {1997},
isbn = {0897918886},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/258533.258660},
doi = {10.1145/258533.258660},
booktitle = {Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing},
pages = {654–663},
numpages = {10},
location = {El Paso, Texas, USA},
series = {STOC '97}
}

  

@article{schneider_implementing_1990,
author = {Schneider, Fred B.},
title = {Implementing fault-tolerant services using the state machine approach: a tutorial},
year = {1990},
issue_date = {Dec. 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {4},
issn = {0360-0300},
url = {https://doi.org/10.1145/98163.98167},
doi = {10.1145/98163.98167},
abstract = {The state machine approach is a general method for implementing fault-tolerant services in distributed systems. This paper reviews the approach and describes protocols for two different failure models—Byzantine and fail stop. Systems reconfiguration techniques for removing faulty components and integrating repaired components are also discussed.},
journal = {ACM Comput. Surv.},
month = dec,
pages = {299–319},
numpages = {21}
}